"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable security/detect-object-injection */
const fetch_node_details_1 = __importDefault(require("@toruslabs/fetch-node-details"));
const openlogin_ed25519_1 = require("@toruslabs/openlogin-ed25519");
const openlogin_subkey_1 = require("@toruslabs/openlogin-subkey");
const base_1 = require("@web3auth/base");
const base_provider_1 = require("@web3auth/base-provider");
const ethereum_provider_1 = require("@web3auth/ethereum-provider");
const solana_provider_1 = require("@web3auth/solana-provider");
const node_fetch_1 = __importDefault(require("node-fetch"));
const web3_utils_1 = require("web3-utils");
const constants_1 = require("./constants");
// eslint-disable-next-line n/no-unsupported-features/es-builtins
globalThis.fetch = node_fetch_1.default;
// eslint-disable-next-line @typescript-eslint/no-var-requires
const TorusUtils = require("@toruslabs/torus.js/dist/torusUtils-node").default;
class Web3Auth {
    constructor(options) {
        var _a, _b;
        this.provider = null;
        this.torusUtils = null;
        this.nodeDetailManager = null;
        this.privKeyProvider = null;
        this.chainConfig = null;
        if (!((_a = options === null || options === void 0 ? void 0 : options.chainConfig) === null || _a === void 0 ? void 0 : _a.chainNamespace)) {
            throw base_1.WalletInitializationError.invalidParams("Please provide a valid chainNamespace in chainConfig");
        }
        if (!options.clientId)
            throw base_1.WalletInitializationError.invalidParams("Please provide a valid clientId in constructor");
        if (((_b = options.chainConfig) === null || _b === void 0 ? void 0 : _b.chainNamespace) !== base_1.CHAIN_NAMESPACES.OTHER) {
            const { chainId, rpcTarget } = (options === null || options === void 0 ? void 0 : options.chainConfig) || {};
            if (!chainId) {
                throw base_1.WalletInitializationError.invalidProviderConfigError("Please provide chainId inside chainConfig");
            }
            if (!rpcTarget) {
                throw base_1.WalletInitializationError.invalidProviderConfigError("Please provide rpcTarget inside chainConfig");
            }
            this.chainConfig = Object.assign({ displayName: "", blockExplorer: "", ticker: "", tickerName: "", chainId: options.chainConfig.chainId, rpcTarget: options.chainConfig.rpcTarget, chainNamespace: options.chainConfig.chainNamespace }, ((options === null || options === void 0 ? void 0 : options.chainConfig) || {}));
        }
        this.currentChainNamespace = options.chainConfig.chainNamespace;
        this.options = Object.assign(Object.assign({}, options), { web3AuthNetwork: options.web3AuthNetwork || "mainnet" });
    }
    init() {
        const { web3AuthNetwork: network } = this.options;
        this.torusUtils = new TorusUtils({
            enableOneKey: true,
            network,
            allowHost: `${constants_1.SIGNER_MAP[network]}/api/allow`,
            signerHost: `${constants_1.SIGNER_MAP[network]}/api/sign`,
            enableLogging: this.options.enableLogging,
        });
        this.nodeDetailManager = new fetch_node_details_1.default({ network, proxyAddress: constants_1.CONTRACT_MAP[network] });
        if (this.currentChainNamespace === base_1.CHAIN_NAMESPACES.SOLANA) {
            this.privKeyProvider = new solana_provider_1.SolanaPrivateKeyProvider({ config: { chainConfig: this.chainConfig } });
        }
        else if (this.currentChainNamespace === base_1.CHAIN_NAMESPACES.EIP155) {
            this.privKeyProvider = new ethereum_provider_1.EthereumPrivateKeyProvider({ config: { chainConfig: this.chainConfig } });
        }
        else if (this.currentChainNamespace === base_1.CHAIN_NAMESPACES.OTHER) {
            this.privKeyProvider = new base_provider_1.CommonPrivateKeyProvider();
        }
        else {
            throw base_1.WalletInitializationError.incompatibleChainNameSpace(`Invalid chainNamespace: ${this.currentChainNamespace} found while connecting to wallet`);
        }
    }
    connect(loginParams) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.torusUtils || !this.nodeDetailManager || !this.privKeyProvider)
                throw new Error("Please call init first");
            const { verifier, verifierId, idToken, subVerifierInfoArray } = loginParams;
            const verifierDetails = { verifier, verifierId };
            const { torusNodeEndpoints, torusIndexes, torusNodePub } = yield this.nodeDetailManager.getNodeDetails(verifierDetails);
            // does the key assign
            const pubDetails = yield this.torusUtils.getUserTypeAndAddress(torusNodeEndpoints, torusNodePub, verifierDetails, true);
            if (pubDetails.typeOfUser === "v1" || pubDetails.upgraded) {
                throw base_1.WalletLoginError.fromCode(5000, "User has already enabled mfa, please use the @web3auth/web3auth-web sdk for login with mfa");
            }
            let finalIdToken = idToken;
            let finalVerifierParams = { verifier_id: verifierId };
            if (subVerifierInfoArray && (subVerifierInfoArray === null || subVerifierInfoArray === void 0 ? void 0 : subVerifierInfoArray.length) > 0) {
                const aggregateVerifierParams = { verify_params: [], sub_verifier_ids: [], verifier_id: "" };
                const aggregateIdTokenSeeds = [];
                for (let index = 0; index < subVerifierInfoArray.length; index += 1) {
                    const userInfo = subVerifierInfoArray[index];
                    aggregateVerifierParams.verify_params.push({ verifier_id: verifierId, idtoken: userInfo.idToken });
                    aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
                    aggregateIdTokenSeeds.push(userInfo.idToken);
                }
                aggregateIdTokenSeeds.sort();
                finalIdToken = (0, web3_utils_1.keccak256)(aggregateIdTokenSeeds.join(String.fromCharCode(29))).slice(2);
                aggregateVerifierParams.verifier_id = verifierId;
                finalVerifierParams = aggregateVerifierParams;
            }
            const retrieveSharesResponse = yield this.torusUtils.retrieveShares(torusNodeEndpoints, torusIndexes, verifier, finalVerifierParams, finalIdToken);
            const { privKey } = retrieveSharesResponse;
            if (!privKey)
                throw base_1.WalletLoginError.fromCode(5000, "Unable to get private key from torus nodes");
            let finalPrivKey = privKey.padStart(64, "0");
            if (this.currentChainNamespace === base_1.CHAIN_NAMESPACES.SOLANA) {
                finalPrivKey = (0, openlogin_ed25519_1.getED25519Key)(finalPrivKey).sk.toString("hex");
            }
            if (this.options.usePnPKey) {
                const pnpPrivKey = (0, openlogin_subkey_1.subkey)(finalPrivKey, Buffer.from(this.options.clientId, "base64"));
                finalPrivKey = pnpPrivKey.padStart(64, "0");
            }
            yield this.privKeyProvider.setupProvider(finalPrivKey);
            return this.privKeyProvider.provider;
        });
    }
}
exports.default = Web3Auth;
//# sourceMappingURL=Web3Auth.js.map